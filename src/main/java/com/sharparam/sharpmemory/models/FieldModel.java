package com.sharparam.sharpmemory.models;

import com.sharparam.sharpmemory.Difficulty;
import com.sharparam.sharpmemory.SharpMemory;
import com.sharparam.sharpmemory.State;
import com.sharparam.sharpmemory.events.FieldEventListener;
import com.sharparam.sharpmemory.events.FieldEventType;
import com.sharparam.sharpmemory.helpers.BrickHelper;
import com.sharparam.sharpmemory.helpers.RandomHelper;
import javafx.scene.image.Image;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

/**
 * FieldModel class to organize bricks.
 *
 * Created by on 2014-03-27.
 *
 * @author Sharparam
 */
public class FieldModel {
    /**
     * Delay until a pair of flipped bricks is checked.
     */
    private static final int TRY_DELAY = 1000;

    /**
     * Difficulty modifiers control the number of bricks placed on the field.
     */
    private static final HashMap<Difficulty, Integer> DIFF_MODIFIERS = new HashMap<Difficulty, Integer>(3) {
        {
            put(Difficulty.EASY, 1);
            put(Difficulty.MEDIUM, 2);
            put(Difficulty.HARD, 3);
        }
    };

    /**
     * Registered event listeners.
     */
    private final ArrayList<FieldEventListener> fieldEventListeners = new ArrayList<FieldEventListener>();

    /**
     * Timer for delaying the match check.
     */
    private Timer tryTimer;

    /**
     * The bricks that are on this field.
     */
    private BrickModel[] bricks;

    /**
     * True if the user has just flipped two bricks and the system is waiting for the
     * try delay to expire before checking the bricks, false otherwise.
     */
    private boolean tryInProgress = false;

    /**
     * Initializes a new instance of this FieldModel with the given array of bricks.
     * @param bricks Array of bricks to initialize with.
     */
    public FieldModel(BrickModel[] bricks) {
        this.bricks = bricks;
    }

    /**
     * Initializes a new instance of this FieldModel with the given list of bricks.
     * @param bricks List of bricks to initialize with.
     */
    public FieldModel(ArrayList<BrickModel> bricks) {
        this.bricks = (BrickModel[]) bricks.toArray();
    }

    /**
     * Initializes a new instance of this FieldModel with the default amount of bricks,
     * generated by the randomize methods.
     */
    public FieldModel() {
        this(5);
    }

    /**
     * Initializes a new instance of this FieldModel with the specified amount of bricks,
     * generated by the randomize methods.
     * @param brickCount Number of bricks to initialize.
     */
    public FieldModel(int brickCount) {
        // brickCount is the number of UNIQUE bricks
        // this has to be doubled because each one has a dupe
        Difficulty diff = SharpMemory.getInstance().getDifficulty();
        bricks = new BrickModel[brickCount * 2 * DIFF_MODIFIERS.get(diff)];
        randomizeBricks(diff);
    }

    /**
     * Returns whether a try is currently in progress by the user.
     * @return True if a try is in progress, false otherwise.
     */
    public boolean isTryInProgress() {
        return tryInProgress;
    }

    /**
     * Adds an event listener to this FieldModel.
     * @param listener Instance of a listener interface.
     */
    public void addEventListener(FieldEventListener listener) {
        fieldEventListeners.add(listener);
    }

    /**
     * Sends the specified event to all event listeners.
     * @param type Type of event to send.
     */
    private void sendEvent(FieldEventType type) {
        for (FieldEventListener listener : fieldEventListeners)
            listener.handle(type);
    }

    /**
     * Gets whether this FieldModel contains a brick at the specified index.
     * @param index Index to check.
     * @return True if a brick exists at the index, false otherwise.
     */
    public boolean hasBrick(int index) {
        return index >= 0 && index < bricks.length;
    }

    /**
     * Gets the brick at the specified index.
     * @param index Index to get.
     * @return The BrickModel at the specified index.
     */
    public BrickModel getBrick(int index) throws ArrayIndexOutOfBoundsException {
        return bricks[index];
    }

    /**
     * Gets the number of bricks in this FieldModel.
     * @return Number of bricks.
     */
    public int getBrickCount() {
        return bricks.length;
    }

    /**
     * Gets the number of bricks that are currently in play.
     * That is, not cleared.
     * @return Number of active bricks.
     */
    public int getActiveBrickCount() {
        int count = 0;
        for (BrickModel brick : bricks)
            if (!brick.isCleared())
                count++;
        return count;
    }

    /**
     * Gets the state of the brick at the specified index.
     * @param index Index to check.
     * @return State of the brick.
     */
    public State getBrickState(int index) {
        return hasBrick(index) ? getBrick(index).getState() : State.INVALID;
    }

    /**
     * Checks if two bricks match each other.
     * @param a Brick A.
     * @param b Brick B.
     * @return True if they match, false otherwise.
     * @deprecated Use the equals method on BrickModel.
     */
    @Deprecated
    public boolean isMatch(BrickModel a, BrickModel b) {
        return a.getImage() == b.getImage();
    }

    /**
     * This removes the specified BrickModel and it's dupe version.
     * @param brick The BrickModel object to remove.
     */
    public void clearBrick(BrickModel brick) {
        for (BrickModel b : bricks)
            if (b.equals(brick))
                b.clear();
    }

    /**
     * Clears the pair of bricks if they are a match.
     * @param a Brick A.
     * @param b Brick B.
     */
    public void clearIfMatch(BrickModel a, BrickModel b) {
        sendEvent(FieldEventType.TRY);

        if (!isMatch(a, b)) {
            sendEvent(FieldEventType.FAIL);
            return;
        }

        clearBrick(a);
        clearBrick(b); // Just to be on the safe side, but this is probably redundant.
        sendEvent(FieldEventType.CLEAR);
    }

    /**
     * Gets the number of bricks that are currently faced up.
     * @return Number of face-up bricks.
     */
    public int getFacedUpCount() {
        int count = 0;
        for (BrickModel brick : bricks)
            if (brick.getState() == State.FACE_UP)
                count++;
        return count;
    }

    /**
     * Gets the number of bricks that have been cleared.
     * @return Number of cleared bricks.
     */
    public int getClearedCount() {
        int count = 0;
        for (BrickModel brick : bricks)
            if (brick.isCleared())
                count++;
        return count;
    }

    /**
     * Flips a brick, making it face up.
     * @param brick The brick to flip.
     */
    public void flipBrick(BrickModel brick) {
        if (brick.isCleared() || brick.getState() == State.FACE_UP || brick.getState() == State.INVALID)
            return;
        brick.flip();
        checkBricks();
    }

    /**
     * Flips the brick at the specified index, if it exists.
     * @param index Brick index to flip.
     */
    public void flipBrick(int index) {
        if (hasBrick(index))
            flipBrick(getBrick(index));
    }

    /**
     * Runs a check on all bricks and applies necessary operations.
     * Makes sure that brick matching is run when == 2 bricks have been flipped.
     * Resets brick states if > 2 bricks are flipped or after a brick match run.
     */
    public void checkBricks() {
        if (getFacedUpCount() < 2)
            return;

        ArrayList<BrickModel> facedUp = new ArrayList<BrickModel>();
        for (BrickModel brick : bricks)
            if (brick.getState() == State.FACE_UP)
                facedUp.add(brick);
        if (facedUp.size() > 2) {
            resetBrickStates();
            return;
        }

        if (tryInProgress)
            return;

        tryInProgress = true;

        final BrickModel a = facedUp.get(0);
        final BrickModel b = facedUp.get(1);

        // Workaround to make application close properly
        if (tryTimer == null)
            tryTimer = new Timer();

        // We want to run the match check and reset only after a set amount of time
        // this way the user will be able to see the bricks before they are cleared or reset.
        tryTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                clearIfMatch(a, b);
                resetBrickStates();
                if (getClearedCount() == getBrickCount())
                    sendEvent(FieldEventType.ALL_BRICKS_CLEARED);
                tryTimer.cancel();
                tryTimer = null;
            }
        }, TRY_DELAY);
    }

    /**
     * Resets all bricks to their default state.
     */
    public void resetBrickStates() {
        for (BrickModel brick : bricks)
            if (!brick.isCleared())
                brick.faceDown();
        tryInProgress = false;
    }

    /**
     * Calls randomizeBricks with EASY as argument.
     * @see #randomizeBricks(com.sharparam.sharpmemory.Difficulty)
     */
    private void randomizeBricks() {
        randomizeBricks(Difficulty.EASY);
    }

    /**
     * Places out random bricks on the board based on predefined lists.
     * @param diff Difficulty to use.
     */
    private void randomizeBricks(Difficulty diff) {
        String diffString = diff.toString().toLowerCase();
        randomizeBricks(diffString);
    }

    /**
     * Randomizes bricks based on difficulty.
     * @param diff Name of difficulty, corresponds to directories in resources/images
     */
    private void randomizeBricks(String diff) {
        Image[] images = new Image[getBrickCount()];

        int halfCount = getBrickCount() / 2;

        for (int i = 0; i < halfCount; i++) {
            Image image = BrickHelper.getImage("/images/" + diff + "/" + i + ".png");
            images[i] = image;
            images[i + halfCount] = image;
        }

        randomizeImages(images);

        for (int i = 0; i < bricks.length; i++)
            bricks[i] = new BrickModel(images[i]);
    }

    /**
     * Randomizes the given image array, shuffling the elements.
     * @param images Image array to randomize.
     */
    private void randomizeImages(Image[] images)
    {
        int index;
        Image temp;
        for (int i = images.length - 1; i > 0; i--)
        {
            index = RandomHelper.RNG.nextInt(i + 1);
            temp = images[index];
            images[index] = images[i];
            images[i] = temp;
        }
    }
}
